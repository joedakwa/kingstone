[C] BNB is stuck within the feeAccount forever.

During purchaseItem, the payable modifier in Solidity is used to send BNB to the feeAccount.

However, there is currently no way to withdraw BNB from the feeAccount.

This means that once BNB is sent to the feeAccount, it will remain there indefinitely, and there is no automated way for the contract owner to retrieve those funds.

Mitigation:

 // Withdraw accumulated BNB from the fee account
    function withdrawFees() public {
        require(msg.sender == owner, "Not Owner");
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds available for withdrawal");
        payable(owner).transfer(balance);
    }

----------------------------

[H] The owner can change the fee structure at any time, resulting in losses for buyers and gains for sellers.

In changeFee, it is set to be called only by the owner.


    function changeFee (uint _newFee) public {
        require(msg.sender == owner, "Not Owner");
        feePercent = _newFee;
    }

However, this is a centralisation risk, as the owner can change the fee structure at any time, even during key 
execution during purchaseItem.

POC:

User lists NFT for sale at 1 BNB.

Buyer calls purchaseItem and passes in the _item obeject and 1 BNB.

The function checks that msg.value is greater than or equal to the price of the item, and then calculates the fee.

  require(msg.value >= _totalPrice, "Insufficient funds");
        //send Fee to Markeplace owner
        feeAccount.transfer(_totalPrice * feePercent / 1000);

So we get _totalPrice * feePercent / 1000 = 1 * 25 / 1000 = 0.025 BNB

Now, the owner changes the feePercent to say 50 from 25.

So we get _totalPrice * feePercent / 1000 = 1 * 50 / 1000 = 0.05 BNB.

So the owner has doubled the fee, and the buyer has no way of knowing this, which means the seller will receive
more than they expected, and the buyer will pay more than they expected by the time the below call is made.

        //send remaining BNB to seller

payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000);

Mitigation:

Set a constant feePercent as a state variable, set a local variable to store the current feePercent in the function or only allow fees to be changed if the contract
is paused. (Import OZ pausable library) This may mitigate this scenario, coupled with notifying users of the change in fees.

-------------------------

[C] Malicious seller can steal funds from buyer by calling unlistItem 

In purchaseItem, there is a call to transfer the proceeds of the sale to the seller.

        //send remaining BNB to seller
        payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000);

However, the seller can call unlistItem right after this, which will result in the buyer losing their funds, as
unlistItem deletes the item from the items array.

This means that the seller has just received proceeds before the item has even been transferred to the buyer.

The buyer will not receive the NFT, because unlistItem deletes the item from the items array.

Mitigation:

Add a check to see if the item is still in the items array before transferring funds to the seller.

I would recommend to change the sequence management and synchronization of the function flow between
purchaseItem and unlistItem. Allow for the automatic delisting of the NFT only after transferFrom has been successfully executed and the buyer has the NFT.

----------------

[H] listItem doesn't check if the seller of the NFT is the owner of the NFT, which can lead to loss of funds for buyers.

There is only currently a call to isApprovedForAll to check if the contract is authorised to transfer the NFT.

However, there is no explicit check to see if the seller of the NFT is the owner.

This means that anyone can list an NFT for sale, even if they don't own it.

So when a malicious seller lists an item for sale, and a buyer then calls purchaseItem, the malicious seller
will receive the funds, but the buyer will not receive the NFT.


            payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000);

Because there is no check to see if the seller is the owner of the NFT, the seller can steal the funds from the buyer and the buyer will not receive the NFT.


Mitigation:

Add a check to see if the seller is the owner of the NFT before listing it for sale.

require(_nft.ownerOf(_id) == msg.sender, "Not the owner of this NFT");

-------------------------------------------


[H] An attacker can frontrun the seller and list an NFT for a low price, and then purchase the same NFT.

In listItem there are no checks to see if the NFT is owned by the original caller of the function.

There is also no check to see if the NFT is already listed for sale.

Therefore, once a seller calls listItem, the transaction will hang in the mempool.

The attacker, observing the mempool, can list that same NFT for a lower price, and then call purchaseItem.

Stealing the NFT from the seller and receiving the funds from the buyer (himself), 
as he listed the NFT, when he calls purchaseItem. He is also able to receive the sale fee,

            payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000);

 as he listed the NFT.

He then calls unlist item and the item is no longer for sale.

The attacker does this by submitting a higher gas fee than the genuine seller, which gets his transaction
processed before the genuine seller's transaction.

Mitigation:

Refactor the code to check if the NFT is owned by the caller of listItem, 
and also check if the NFT is already listed for sale.


----------------------------------------

[H] Attacker can frontrun the seller and purchase the NFT before the seller's unlistItem transaction is processed.

Lets say a seller wants to unlist the NFT..

He does so by calling unlistItem.

Lets now say a nefarious actor observes this transaction hanging in the mempool, 
they now decide to quickly call purchaseItem passing in the same params of the NFT.

This happens before the seller's transaction is processed.

The nefarious actor now owns the NFT and the seller has lost the NFT.

Mitigation:

When the seller initiates the unlisting of an item, instead of immediately deleting the listing, you can mark it as "unlisted" in the contract state.
Before allowing a purchase through the purchaseItem function, check if the item is marked as "unlisted." If it is, prevent the purchase.
After a certain period of time or once the unlisting transaction is confirmed, you can allow the listing to be fully removed from the contract state.


-----------------------------





