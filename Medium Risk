[M] Sellers can list the same NFTs consistently 

In the listItem function, there is no check to see if the item is already listed. This means that a seller can list the same NFTs consistently, which will result in the same NFT being listed multiple times..

This will lead to confusion amongst buyers as to which NFT is the genuine one, and will also lead to the seller receiving multiple payments for the same NFT.

Mitigation:

Add a check to see if the item is already listed before listing it.

require(!itemExists[_item[i].id], "Item already listed");

-------------------------

[M] BNB can be paused at Admin level causing failures in transactions

In the midst of purchaseItem, there are 2 calls to transfer BNB.

        //send Fee to Markeplace owner
        feeAccount.transfer(_totalPrice * feePercent / 1000);

        //send remaining BNB to seller
        payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000);

Now, BNB has an admin level function that allows the admin to pause the contract.

If this happens:

Paused Transactions: 
If the native coin is paused or frozen, it would prevent the transfers of BNB between addresses. In the context of your purchaseItem function, this could lead to failures during the execution of the following parts:

The feeAccount.transfer(_totalPrice * feePercent / 1000) line: 
The transfer of the fee from the buyer to the marketplace owner might fail if the native coin is paused.

The payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000) line: 
The transfer of the sale fee to the seller might also fail if the native coin is paused.

The _nft.transferFrom(seller, msg.sender, id) line: If the native coin is paused, this could prevent the transfer of the NFT from the seller to the buyer.

Incomplete Transactions: 

If any part of the transaction fails due to the pause or freeze of the native coin, the transaction might be left in an incomplete state. This could result in the buyer losing their funds without receiving the NFT or the seller not receiving their funds.

Mitigation:

It is wise before any transfer of funds to check if the BNB contract is paused.

------------------------------

[M] Missing return values on BNB transfer

During the purchaseItem function, there is an external call to transfer the fee to the marketplace owner.

        //send Fee to Markeplace owner
        feeAccount.transfer(_totalPrice * feePercent / 1000);

        and 
        //send saleFee
        payable(item.seller).transfer(_item[i].price * (1000-feePercent) / 1000);

However, there is no check to see if the transfer was successful.

If using BNB, it (transfer) will not return a bool on erc20 methods. Missing a return value.
https://twitter.com/Uniswap/status/1072286773554876416


If the transaction reverts after the marketplace owner's fee has been deducted but before the transaction is completed, you might end up in an inconsistent state where the fee has been taken from the buyer but hasn't been received by the marketplace owner.

If the transfer of funds to the seller reverts, the buyer would lose their funds without receiving the NFT, and the seller would not receive their payment.

Mitigation:

Its important to use the .call method when calling external contracts, and check the return value, rather than .transfer.

For example:

// Sending fee to marketplace owner
(bool feeTransferSuccess, ) = feeAccount.call{value: _totalPrice * feePercent / 1000}("");
require(feeTransferSuccess, "Fee transfer failed");

// Sending sale fee to seller
(bool saleFeeTransferSuccess, ) = payable(item.seller).call{value: _item[i].price * (1000-feePercent) / 1000}("");
require(saleFeeTransferSuccess, "Sale fee transfer failed");

Keep in mind .call can open up for reentrancy attacks, so alteratively use Open Zeppellins sendValue method.

---------------------------

[M] transferFrom doesnt revert the transaction upon failure

In the purchaseItem function, there is a call to transfer the NFT from the seller to the buyer.

        //transfer NFT to buyer
        _nft.transferFrom(seller, msg.sender, id);

However, if this transfer fails, the transaction will not revert.

This means that the buyer will lose their funds, but will not receive the NFT. As the mapping of the item to the buyer will not be updated, as its been deleted from the items array.

Mitigation:

Use Open Zeppellins SafeERC20 library, which will revert the transaction if the transfer fails.

_nft.safeTransferFrom(seller, msg.sender, id);

----------------------------

[M] Block gas limit can be reached in purchaseItem

In the purchaseItem function, there are 2 for loops, which iterate over the items array.

There are several state changes taking place in this function, which will result in higher gas fees than usual.

When the items array is large, this could result in the block gas limit being reached, which would result in the transaction failing.

Mitigation:

Combine multiple operations into a single loop to reduce the number of iterations. For instance, batch the transfer of NFTs and payments to sellers together in a single loop.

----------------------



